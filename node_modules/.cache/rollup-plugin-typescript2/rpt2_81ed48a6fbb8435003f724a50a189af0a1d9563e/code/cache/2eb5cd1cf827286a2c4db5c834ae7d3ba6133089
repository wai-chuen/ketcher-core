{"code":"/****************************************************************************\r\n * Copyright 2021 EPAM Systems\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n ***************************************************************************/\r\nimport { Pile } from './pile';\r\nimport { SGroup } from './sgroup';\r\nimport assert from 'assert';\r\nexport class SGroupForest {\r\n    /** node id -> parent id */\r\n    parent;\r\n    /** node id -> list of child ids */\r\n    children;\r\n    atomSets;\r\n    constructor() {\r\n        this.parent = new Map();\r\n        this.children = new Map();\r\n        this.children.set(-1, []); // extra root node\r\n        this.atomSets = new Map();\r\n    }\r\n    /** returns an array or s-group ids in the order of breadth-first search */\r\n    getSGroupsBFS() {\r\n        const order = [];\r\n        const queue = Array.from(this.children.get(-1));\r\n        while (queue.length > 0) {\r\n            const id = queue.shift();\r\n            if (typeof id !== 'number') {\r\n                break;\r\n            }\r\n            const children = this.children.get(id);\r\n            if (typeof children === 'undefined') {\r\n                break;\r\n            }\r\n            children.forEach((id) => {\r\n                queue.push(id);\r\n            });\r\n            order.push(id);\r\n        }\r\n        return order;\r\n    }\r\n    getAtomSetRelations(newId, atoms) {\r\n        // find the lowest superset in the hierarchy\r\n        const isStrictSuperset = new Map();\r\n        const isSubset = new Map();\r\n        this.atomSets.delete(newId);\r\n        this.atomSets.forEach((atomSet, id) => {\r\n            isSubset.set(id, atomSet.isSuperset(atoms));\r\n            isStrictSuperset.set(id, atoms.isSuperset(atomSet) && !atomSet.equals(atoms));\r\n        });\r\n        const parents = Array.from(this.atomSets.keys()).filter((sgid) => {\r\n            if (!isSubset.get(sgid)) {\r\n                return false;\r\n            }\r\n            const childs = this.children.get(sgid);\r\n            return childs && childs.findIndex((childId) => isSubset.get(childId)) < 0;\r\n        });\r\n        const children = Array.from(this.atomSets.keys()).filter((id) => isStrictSuperset.get(id) && !isStrictSuperset.get(this.parent.get(id)));\r\n        return {\r\n            children,\r\n            parent: parents.length === 0 ? -1 : parents[0]\r\n        };\r\n    }\r\n    getPathToRoot(sgid) {\r\n        const path = [];\r\n        for (let id = sgid; id >= 0; id = this.parent.get(id)) {\r\n            path.push(id);\r\n        }\r\n        return path;\r\n    }\r\n    insert({ id, atoms }, parent, children) {\r\n        assert(!this.parent.has(id), 'sgid already present in the forest');\r\n        assert(!this.children.has(id), 'sgid already present in the forest');\r\n        if (!parent || !children) {\r\n            // if these are not provided, deduce automatically\r\n            const guess = this.getAtomSetRelations(id, new Pile(atoms));\r\n            parent = guess.parent;\r\n            children = guess.children;\r\n        }\r\n        // TODO: make children Map<int, Pile> instead of Map<int, []>?\r\n        children.forEach((childId) => {\r\n            this.resetParentLink(childId, id);\r\n        });\r\n        this.children.set(id, children.filter((id) => this.parent.get(id)));\r\n        this.parent.set(id, parent);\r\n        this.children.get(parent)?.push(id);\r\n        this.atomSets.set(id, new Pile(atoms));\r\n        return { parent, children };\r\n    }\r\n    resetParentLink(childId, id) {\r\n        const parentId = this.parent.get(childId);\r\n        if (typeof parentId === 'undefined') {\r\n            return;\r\n        }\r\n        const childs = this.children.get(parentId);\r\n        if (!childs) {\r\n            return;\r\n        }\r\n        const childIndex = childs.indexOf(childId);\r\n        childs.splice(childIndex, 1);\r\n        this.parent.set(childId, id);\r\n    }\r\n    remove(id) {\r\n        try {\r\n            assert(this.parent.has(id), 'sgid is not in the forest');\r\n            assert(this.children.has(id), 'sgid is not in the forest');\r\n        }\r\n        catch (e) {\r\n            console.info('error: sgid is not in the forest');\r\n        }\r\n        const parentId = this.parent.get(id);\r\n        const childs = this.children.get(parentId);\r\n        if (!parentId || !childs)\r\n            return;\r\n        this.children.get(id)?.forEach((childId) => {\r\n            this.parent.set(childId, parentId);\r\n            this.children.get(parentId)?.push(childId);\r\n        });\r\n        const i = childs.indexOf(id);\r\n        childs.splice(i, 1);\r\n        this.children.delete(id);\r\n        this.parent.delete(id);\r\n        this.atomSets.delete(id);\r\n    }\r\n}\r\nexport function checkOverlapping(struct, atoms) {\r\n    const sgroups = atoms.reduce((res, aid) => {\r\n        const atom = struct.atoms.get(aid);\r\n        return res.union(atom.sgs);\r\n    }, new Pile());\r\n    return Array.from(sgroups).some((sid) => {\r\n        const sg = struct.sgroups.get(sid);\r\n        if (sg.type === 'DAT')\r\n            return false;\r\n        const sgAtoms = SGroup.getAtoms(struct, sg);\r\n        return sgAtoms.length < atoms.length\r\n            ? sgAtoms.findIndex((aid) => atoms.indexOf(aid) === -1) >= 0\r\n            : atoms.findIndex((aid) => sgAtoms.indexOf(aid) === -1) >= 0;\r\n    });\r\n}\r\n//# sourceMappingURL=sgroupForest.js.map","references":["/usr/local/google/home/waich/workspace/ketcher/packages/ketcher-core/src/domain/entities/pile.ts","/usr/local/google/home/waich/workspace/ketcher/packages/ketcher-core/src/domain/entities/sgroup.ts","/usr/local/google/home/waich/workspace/ketcher/node_modules/assert/build/assert.js"],"map":"{\"version\":3,\"file\":\"sgroupForest.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../src/domain/entities/sgroupForest.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/usr/local/google/home/waich/workspace/ketcher/packages/ketcher-core/node_modules/.cache/rollup-plugin-typescript2/placeholder/domain/entities/sgroupForest.d.ts","writeByteOrderMark":false,"text":"/****************************************************************************\r\n * Copyright 2021 EPAM Systems\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n ***************************************************************************/\r\nexport declare class SGroupForest {\r\n    /** node id -> parent id */\r\n    parent: Map<number, number>;\r\n    /** node id -> list of child ids */\r\n    children: Map<number, number[]>;\r\n    atomSets: Map<number, any>;\r\n    constructor();\r\n    /** returns an array or s-group ids in the order of breadth-first search */\r\n    getSGroupsBFS(): number[];\r\n    getAtomSetRelations(newId: any, atoms: any): {\r\n        children: number[];\r\n        parent: number;\r\n    };\r\n    getPathToRoot(sgid: any): number[];\r\n    insert({ id, atoms }: {\r\n        id: any;\r\n        atoms: any;\r\n    }, parent?: number, children?: number[]): {\r\n        parent: number;\r\n        children: number[];\r\n    };\r\n    private resetParentLink;\r\n    remove(id: any): void;\r\n}\r\nexport declare function checkOverlapping(struct: any, atoms: any): boolean;\r\n"}}
