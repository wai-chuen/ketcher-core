{"code":"import assert from 'assert';\r\nimport { FunctionalGroupsProvider } from '../helpers';\r\nimport { SGroup } from './sgroup';\r\nexport class FunctionalGroup {\r\n    #sgroup;\r\n    constructor(sgroup) {\r\n        assert(sgroup != null);\r\n        this.#sgroup = sgroup;\r\n    }\r\n    get name() {\r\n        return this.#sgroup.data.name;\r\n    }\r\n    get relatedSGroupId() {\r\n        return this.#sgroup.id;\r\n    }\r\n    get isExpanded() {\r\n        return this.#sgroup.data.expanded;\r\n    }\r\n    get relatedSGroup() {\r\n        return this.#sgroup;\r\n    }\r\n    static isFunctionalGroup(sgroup) {\r\n        const provider = FunctionalGroupsProvider.getInstance();\r\n        const functionalGroups = provider.getFunctionalGroupsList();\r\n        const { data: { name }, type } = sgroup;\r\n        return (type === 'SUP' &&\r\n            (functionalGroups.some((type) => type.name === name) ||\r\n                SGroup.isSaltOrSolvent(name)));\r\n    }\r\n    static getFunctionalGroupByName(searchName) {\r\n        const provider = FunctionalGroupsProvider.getInstance();\r\n        const functionalGroups = provider.getFunctionalGroupsList();\r\n        let foundGroup;\r\n        if (searchName) {\r\n            foundGroup = functionalGroups.find(({ name, abbreviation }) => {\r\n                return name === searchName || abbreviation === searchName;\r\n            });\r\n        }\r\n        return foundGroup || null;\r\n    }\r\n    static atomsInFunctionalGroup(functionalGroups, atom) {\r\n        if (functionalGroups.size === 0) {\r\n            return null;\r\n        }\r\n        for (const fg of functionalGroups.values()) {\r\n            if (fg.relatedSGroup.atoms.includes(atom))\r\n                return atom;\r\n        }\r\n        return null;\r\n    }\r\n    static bondsInFunctionalGroup(molecule, functionalGroups, bond) {\r\n        if (functionalGroups.size === 0) {\r\n            return null;\r\n        }\r\n        for (const fg of functionalGroups.values()) {\r\n            const bonds = SGroup.getBonds(molecule, fg.relatedSGroup);\r\n            if (bonds.includes(bond))\r\n                return bond;\r\n        }\r\n        return null;\r\n    }\r\n    static findFunctionalGroupByAtom(functionalGroups, atomId, isFunctionalGroupReturned) {\r\n        for (const fg of functionalGroups.values()) {\r\n            if (fg.relatedSGroup.atoms.includes(atomId))\r\n                return isFunctionalGroupReturned ? fg : fg.relatedSGroupId;\r\n        }\r\n        return null;\r\n    }\r\n    static findFunctionalGroupByBond(molecule, functionalGroups, bondId, isFunctionalGroupReturned) {\r\n        for (const fg of functionalGroups.values()) {\r\n            const bonds = SGroup.getBonds(molecule, fg.relatedSGroup);\r\n            if (bonds.includes(bondId)) {\r\n                return isFunctionalGroupReturned ? fg : fg.relatedSGroupId;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    static findFunctionalGroupBySGroup(functionalGroups, sGroup) {\r\n        const key = functionalGroups.find((_, functionalGroup) => functionalGroup.relatedSGroupId === sGroup?.id);\r\n        return key !== null ? functionalGroups.get(key) : undefined;\r\n    }\r\n    static clone(functionalGroup) {\r\n        return new FunctionalGroup(functionalGroup.#sgroup);\r\n    }\r\n    static isAttachmentBond(sgroup, { begin, end }) {\r\n        return ((sgroup.atoms.includes(begin) && !sgroup.atoms.includes(end)) ||\r\n            (sgroup.atoms.includes(end) && !sgroup.atoms.includes(begin)));\r\n    }\r\n    // Checks, if S-Group is standalone or attached to some other structure\r\n    static isAttachedSGroup(sgroup, molecule) {\r\n        const { bonds } = molecule;\r\n        for (const bond of bonds.values()) {\r\n            if (FunctionalGroup.isAttachmentBond(sgroup, bond)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * This function determines, if an atom is used for attachment to other structure.\r\n     * For example, having sgroup CF3, which looks like\r\n     *              F\r\n     *              |\r\n     *            F-C-F\r\n     *              |\r\n     *         other struct\r\n     * C – is an attachment point\r\n     */\r\n    static isAttachmentPointAtom(atomId, molecule) {\r\n        const { sgroups, bonds } = molecule;\r\n        const isAtomInSameFunctionalGroup = (otherAtomId, sgroup) => sgroup.atoms.includes(otherAtomId);\r\n        for (const sgroup of sgroups.values()) {\r\n            const isFunctionalGroup = FunctionalGroup.isFunctionalGroup(sgroup);\r\n            const isSGroupFound = sgroup.atoms.includes(atomId);\r\n            if (!isFunctionalGroup || !isSGroupFound) {\r\n                continue;\r\n            }\r\n            for (const bond of bonds.values()) {\r\n                const isBondBeginInSGroupAndBondEndOutside = bond.begin === atomId &&\r\n                    !isAtomInSameFunctionalGroup(bond.end, sgroup);\r\n                const isBondEndInSGroupAndBondBeginOutside = bond.end === atomId &&\r\n                    !isAtomInSameFunctionalGroup(bond.begin, sgroup);\r\n                const isAttachmentBond = isBondBeginInSGroupAndBondEndOutside ||\r\n                    isBondEndInSGroupAndBondBeginOutside;\r\n                if (isAttachmentBond) {\r\n                    return true;\r\n                }\r\n            }\r\n            // if atom in S-Group, which is not attached to any structure, then\r\n            // atoms[0] is considered as attachment point\r\n            if (!this.isAttachedSGroup(sgroup, molecule)) {\r\n                return sgroup.atoms[0] === atomId;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    static isFirstAtomInFunctionalGroup(sgroups, aid) {\r\n        for (const sg of sgroups.values()) {\r\n            if (FunctionalGroup.isFunctionalGroup(sg) && aid === sg.atoms[0]) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    static isAtomInContractedFunctionalGroup(atom, sgroups, functionalGroups, sgroupsFromReStruct) {\r\n        const contractedFunctionalGroups = [];\r\n        if (sgroupsFromReStruct) {\r\n            sgroups.forEach((sg) => {\r\n                if (FunctionalGroup.isContractedFunctionalGroup(sg.item.id, functionalGroups)) {\r\n                    contractedFunctionalGroups.push(sg.item.id);\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            sgroups.forEach((sg) => {\r\n                if (FunctionalGroup.isContractedFunctionalGroup(sg.id, functionalGroups)) {\r\n                    contractedFunctionalGroups.push(sg.id);\r\n                }\r\n            });\r\n        }\r\n        return contractedFunctionalGroups.some((sg) => atom.sgs.has(sg));\r\n    }\r\n    static isBondInContractedFunctionalGroup(bond, sGroups, functionalGroups) {\r\n        return [...sGroups.values()].some((sGroup) => {\r\n            const sGroupId = 'item' in sGroup ? sGroup.item.id : sGroup.id;\r\n            const atomsInSGroup = 'item' in sGroup ? sGroup.item.atoms : sGroup.atoms;\r\n            const isContracted = FunctionalGroup.isContractedFunctionalGroup(sGroupId, functionalGroups);\r\n            return (isContracted &&\r\n                atomsInSGroup.includes(bond.begin) &&\r\n                atomsInSGroup.includes(bond.end));\r\n        });\r\n    }\r\n    static isContractedFunctionalGroup(sgroupId, functionalGroups) {\r\n        let isFunctionalGroup = false;\r\n        let expanded = false;\r\n        functionalGroups.forEach((fg) => {\r\n            if (fg.relatedSGroupId === sgroupId) {\r\n                isFunctionalGroup = true;\r\n                expanded = fg.isExpanded;\r\n            }\r\n        });\r\n        return !expanded && isFunctionalGroup;\r\n    }\r\n}\r\n//# sourceMappingURL=functionalGroup.js.map","references":["/usr/local/google/home/waich/workspace/ketcher/packages/ketcher-core/src/application/render/index.ts","/usr/local/google/home/waich/workspace/ketcher/node_modules/assert/build/assert.js","/usr/local/google/home/waich/workspace/ketcher/packages/ketcher-core/src/domain/helpers/index.ts","/usr/local/google/home/waich/workspace/ketcher/packages/ketcher-core/src/domain/entities/bond.ts","/usr/local/google/home/waich/workspace/ketcher/packages/ketcher-core/src/domain/entities/pool.ts","/usr/local/google/home/waich/workspace/ketcher/packages/ketcher-core/src/domain/entities/sgroup.ts","/usr/local/google/home/waich/workspace/ketcher/packages/ketcher-core/src/domain/entities/struct.ts"],"map":"{\"version\":3,\"file\":\"functionalGroup.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../../../../src/domain/entities/functionalGroup.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/usr/local/google/home/waich/workspace/ketcher/packages/ketcher-core/node_modules/.cache/rollup-plugin-typescript2/placeholder/domain/entities/functionalGroup.d.ts","writeByteOrderMark":false,"text":"/****************************************************************************\r\n * Copyright 2021 EPAM Systems\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *    http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n ***************************************************************************/\r\nimport { ReSGroup } from \"../../application/render\";\r\nimport { Bond } from './bond';\r\nimport { Pool } from './pool';\r\nimport { SGroup } from './sgroup';\r\nimport { Struct } from './struct';\r\nexport declare class FunctionalGroup {\r\n    #private;\r\n    constructor(sgroup: SGroup);\r\n    get name(): string;\r\n    get relatedSGroupId(): number;\r\n    get isExpanded(): boolean;\r\n    get relatedSGroup(): SGroup;\r\n    static isFunctionalGroup(sgroup: any): boolean;\r\n    static getFunctionalGroupByName(searchName: string): Struct | null;\r\n    static atomsInFunctionalGroup(functionalGroups: any, atom: any): number | null;\r\n    static bondsInFunctionalGroup(molecule: any, functionalGroups: any, bond: any): number | null;\r\n    static findFunctionalGroupByAtom(functionalGroups: Pool<FunctionalGroup>, atomId: number): number | null;\r\n    static findFunctionalGroupByAtom(functionalGroups: Pool<FunctionalGroup>, atomId: number, isFunctionalGroupReturned: true): FunctionalGroup | null;\r\n    static findFunctionalGroupByBond(molecule: Struct, functionalGroups: Pool<FunctionalGroup>, bondId: number | null): number | null;\r\n    static findFunctionalGroupByBond(molecule: Struct, functionalGroups: Pool<FunctionalGroup>, bondId: number | null, isFunctionalGroupReturned: true): FunctionalGroup | null;\r\n    static findFunctionalGroupBySGroup(functionalGroups: Pool<FunctionalGroup>, sGroup?: SGroup): FunctionalGroup | undefined;\r\n    static clone(functionalGroup: FunctionalGroup): FunctionalGroup;\r\n    static isAttachmentBond(sgroup: any, { begin, end }: {\r\n        begin: any;\r\n        end: any;\r\n    }): any;\r\n    static isAttachedSGroup(sgroup: any, molecule: any): boolean;\r\n    /**\r\n     * This function determines, if an atom is used for attachment to other structure.\r\n     * For example, having sgroup CF3, which looks like\r\n     *              F\r\n     *              |\r\n     *            F-C-F\r\n     *              |\r\n     *         other struct\r\n     * C – is an attachment point\r\n     */\r\n    static isAttachmentPointAtom(atomId: number, molecule: Struct): boolean;\r\n    static isFirstAtomInFunctionalGroup(sgroups: any, aid: any): boolean;\r\n    static isAtomInContractedFunctionalGroup(atom: any, sgroups: any, functionalGroups: any, sgroupsFromReStruct: boolean): boolean;\r\n    static isBondInContractedFunctionalGroup(bond: Bond, sGroups: Map<number, ReSGroup> | Pool<SGroup>, functionalGroups: Pool<FunctionalGroup>): boolean;\r\n    static isContractedFunctionalGroup(sgroupId: any, functionalGroups: any): boolean;\r\n}\r\n"}}
